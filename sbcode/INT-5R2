OPTION DEFINT

RANDOMIZE 0,1

ACLS 1,1,1
GPAGE 0,0
BACKCOLOR #GRAY
GCLS
DIM MEM[&H10000]
VAR OP,X,Y,BYTE,NIB,ADDR,INST
VAR PC
DIM STACK[0]
DIM REG[&H10]

LOCATE ,,-256

WAVSET 255,127,127,127,127,"00FF"*8
BGMPLAY "T100R64@255T1[C1&]"
BGMVOL 0

BADSHIFT=FALSE
BADI=FALSE
BADSP=FALSE
DIM R[0]
VAR KEYS
XSCREEN 2

SPSET 0,0,0,64,32
SPHOME 0,32,16
SPOFS 0,400/2,240/2
SPSCALE 0,6,6
SPPAGE 5
GPAGE 0,SPPAGE()
GCLS

DIM KEY[16]
COPY KEY,@KEY

@KEY
DATA &H1,&H2,&H3,&HC
DATA &H4,&H5,&H6,&HD
DATA &H7,&H8,&H9,&HE
DATA &HA,&H0,&HB,&HF

'KEYPAD
DISPLAY 1
FOR I=0 TO 16-1
 SPSET I,ASC(HEX$(KEY[I]))
 SPHOME I,8,8
 SPCOL I,TRUE
 SPSCALE I,3,3
 SPOFS I,(I MOD 4)*60+30,(I DIV 4)*60+30
NEXT I
DISPLAY 0

USE 1
RESTORE "1:@_"
I=&H200
CLIPBOARD ""
DIM NAMES$[0]
DIM ADDRS[0]

WHILE 1
 VAR TEMP
 READ TEMP
 IF TEMP==-1 THEN
  BREAK
 ELSEIF TEMP==-2 THEN
  READ TEMP$
  PUSH NAMES$,TEMP$
  PUSH ADDRS,I
  CONTINUE
 ELSEIF TEMP<=-3 THEN
  READ TEMP
  READ TEMP$
 ENDIF
 INC I,2
WEND

RESTORE "1:@_"
I=&H200
WHILE 1
 READ TEMP
 IF TEMP==-1 THEN
  BREAK
 ELSEIF TEMP==-2 THEN
  READ TEMP$
  CONTINUE
 ELSEIF TEMP==-3 THEN
  READ TEMP
  READ TEMP$
  FOR U=0 TO LEN(NAMES$)-1
   IF NAMES$[U]==TEMP$ THEN BREAK
  NEXT
  TEMP=TEMP XOR ADDRS[U]
 ELSEIF TEMP==-4 THEN
  READ TEMP
  READ TEMP$
  FOR U=0 TO LEN(NAMES$)-1
   IF NAMES$[U]==TEMP$ THEN BREAK
  NEXT
  TEMP=TEMP XOR (ADDRS[U]+1)
 ENDIF
 
 CLIPBOARD CLIPBOARD()+" 0x"+HEX$(TEMP>>8,2)+" 0x"+HEX$(TEMP AND &HFF,2)
 MEM[I]=TEMP>>8 AND &HFF
 MEM[I+1]=TEMP AND &HFF
 INC I,2
 INC INS,2
WEND


'DIM ROM[0]
'LOAD "DAT:SYZYGY.ROM",ROM,0
'FOR I=0 TO LEN(ROM)-1
' MEM[&H200+I*4+3]=ROM[I]>>24 AND &HFF
' MEM[&H200+I*4+2]=ROM[I]>>16 AND &HFF
' MEM[&H200+I*4+1]=ROM[I]>>8 AND &HFF
' MEM[&H200+I*4+0]=ROM[I]>>0 AND &HFF
'NEXT

COPY MEM,@FONT,16+51
COPY MEM,&H200-4,@SETUP,4

@SETUP
DATA &H00,&HE0 'CLS
DATA &H80,&H00 'NOP

'Hexadecimal font
@FONT
DATA &H30,&H39,&H22,&H2A,&H3E,&H20,&H24,&H34
DATA &H26,&H28,&H2E,&H18,&H14,&H1C,&H10,&H12
DATA &HF0,&H80'E
DATA &HF0,&H80'F
DATA &HF0,&H80,&H80,&H80'C
DATA &HF0,&H50,&H70,&H50'B
DATA &HF0,&H50,&H50,&H50'D
DATA &HF0,&H80,&HF0,&H10'5
DATA &HF0,&H80'6
DATA &HF0,&H90'8
DATA &HF0,&H90'9
DATA &HF0,&H10,&HF0,&H10'3
DATA &HF0,&H90'A
DATA &HF0,&H90,&H90,&H90'0
DATA &HF0,&H10,&H10,&H10,&H10'7
DATA &H60,&H20,&H20,&H20,&H70'1
DATA &HA0,&HA0,&HF0,&H20,&H20'4

PC=&H200-4
VAR ISPD#=0.22008
VAR SPD#=ISPD#
VAR SPDIN#=1000
VAR DELAY#=100
C=MILLISEC
I=0
WHILE 1
 VAR DE=MILLISEC-C
 IF DE>2 THEN DE=2
 SPD#=(SPD#*SPDIN#+DE)/(SPDIN#+1)
 C=MILLISEC
 LOCATE 0,0
 ?FORMAT$("%3.0F%% L%3D",ISPD#/SPD#*100,DELAY#);
 DELAY#=DELAY#*(ISPD#/SPD#)
 IF DELAY#<1 THEN ?" SLOW"
 
 FOR KK=0 TO DELAY#
  IF MAINCNT>LAST THEN
   LAST=MAINCNT
   'INC CYCLES,1024+800
   REF=1
   LAST=MAINCNT
   IF ST>0 THEN
    DEC ST
    BGMVOL 63
   ELSE
    BGMVOL 0
   ENDIF
   IF DT>0 THEN DEC DT
   RAND=RND(&HFF)
   OLDKEYS=KEYS
   KEYS=0
   
   'TOUCH SCREEN
   VAR TT,TX,TY
   TOUCH OUT TT,TX,TY
   IF TT THEN
    DISPLAY 1
    VAR HIT=SPHITRC(0,16-1,TX,TY,1,1)
    IF HIT!=-1 THEN
     KEYS=KEYS OR 1<<KEY[HIT]
    ENDIF
    DISPLAY 0
   ENDIF
   
   IF BUTTON() AND #LEFT THEN KEYS=KEYS OR 1<<4
   IF BUTTON() AND #RIGHT THEN KEYS=KEYS OR 1<<5
   
   IF BUTTON() AND #A THEN KEYS=KEYS OR 1<<&HD
   IF BUTTON() AND #DOWN THEN KEYS=KEYS OR 1<<7

   IF KEYS AND NOT OLDKEYS THEN BEEP 9
  ENDIF
 NEXT
 
 'DEC CYCLES
 'IF CYCLES>0 THEN CONTINUE
 
 GETOP
 'ASM
 ON OP GOSUB @0,@1,@2,@3,@4,@5,@6,@7,@8,@9,@A,@B,@C,@D,@E,@F
 
 PC=PC+2 AND &HFFFF
WEND

DEF ERROR EXCUSE$
 GETINST
 PRINT "         ";HEX$(PC,4);" ";HEX$(INST,4);" ERROR: ";EXCUSE$
END

DEF GETINST
 INST=MEM[PC]<<8 OR MEM[PC+1]
END

DEF GETOP
 OP=MEM[PC]>>4 AND &HF
END
DEF GETX
 X=MEM[PC] AND &HF
END
DEF GETY
 Y=MEM[PC+1]>>4 AND &HF
END
DEF GETBYTE
 BYTE=MEM[PC+1] AND &HFF
END
DEF GETNIB
 NIB=MEM[PC+1] AND &HF
END
DEF GETADDR
 ADDR=(MEM[PC] AND &HF)<<8 OR MEM[PC+1] AND &HFF
END

DEF PUSH_
END

DEF SKIP
 PC=PC+2 AND &HFFFF
END

DEF BACK
 PC=PC-2 AND &HFFFF
END

@0
 GETADDR
 IF ADDR==&H0E0 THEN
  GFILL 0,0,64-1,32-1,#BLACK
  INC CYCLES,26
 ELSEIF ADDR==&H0EE THEN
  PC=POP(STACK)
  INC CYCLES,10
 ELSE
  ERROR "UNSUPPORTED SYS"
 ENDIF
RETURN
'JMP
@1
 GETADDR
 PC=ADDR-2
 INC CYCLES,12
'CALL
RETURN
@2
 GETADDR
 PUSH STACK,PC
 PC=ADDR-2
 INC CYCLES,26
RETURN
@3
 GETX
 GETBYTE
 IF REG[X]==BYTE THEN
  SKIP
  INC CYCLES,14
 ELSE
  INC CYCLES,10
 ENDIF
RETURN
'SNE
@4
 GETX
 GETBYTE
 IF REG[X]!=BYTE THEN
  SKIP
  INC CYCLES,14
 ELSE
  INC CYCLES,10
 ENDIF
RETURN
@5
'SE
 GETX
 GETY
 IF REG[X]==REG[Y] THEN
  SKIP
  INC CYCLES,18
 ELSE
  INC CYCLES,14
 ENDIF
RETURN
'LD
@6
 GETX
 GETBYTE
 REG[X]=BYTE
 INC CYCLES,6
RETURN
@7
'ADD
 GETX
 GETBYTE
 REG[X]=REG[X]+BYTE AND &HFF
 INC CYCLES,10
RETURN
@8
'OPRATIONN
 GETX
 GETY
 GETNIB
 INC CYCLES,44
 ON NIB GOSUB @80,@81,@82,@83,@84,@85,@86,@87,@88,@89,@8A,@8B,@8C,@8D,@8E,@8F
RETURN
@80
 REG[X]=REG[Y]
 INC CYCLES,12
RETURN
@81
 REG[X]=REG[X] OR REG[Y]
RETURN
@82
 REG[X]=REG[X] AND REG[Y]
RETURN
@83
 REG[X]=REG[X] XOR REG[Y]
RETURN
@84
 INC REG[X],REG[Y]
 IF REG[X]>255 THEN
  REG[X]=REG[X] AND &HFF
  REG[&HF]=1
 ELSE
  REG[&HF]=0
 ENDIF
RETURN
@85
 DEC REG[X],REG[Y]
 IF REG[X]<0 THEN
  REG[X]=REG[X] AND &HFF
  REG[&HF]=0
 ELSE
  REG[&HF]=1
 ENDIF
RETURN
@86
 IF BADSHIFT THEN
  REG[&HF]=REG[X] AND &B1
  REG[X]=REG[X]>>1
 ELSE
  REG[&HF]=REG[Y] AND &B1
  REG[Y]=REG[Y]>>1
  REG[X]=REG[Y]
 ENDIF
RETURN
@87
 REG[X]=REG[Y]-REG[X] AND &HFF
RETURN
@8E
 IF BADSHIFT THEN
  REG[&HF]=REG[X]>>7
  REG[X]=REG[X]<<1
 ELSE
  REG[&HF]=REG[Y]>>7
  REG[Y]=REG[Y]<<1
  REG[X]=REG[Y]
 ENDIF
RETURN
@88@89@8A@8B@8C@8D@8F
 ERROR "INVALID MODE"
RETURN
'SNE
@9
 GETX
 GETY
 IF REG[X]!=REG[Y] THEN
  SKIP
  INC CYCLES,18
 ELSE
  INC CYCLES,14
 ENDIF
RETURN
'LDI
@A
 GETADDR
 I=ADDR
 INC CYCLES,12
RETURN
'JMP
@B
 GETADDR
 PC=ADDR+REG[0]-2
 INC CYCLES,(22+24)/2
RETURN
@C
'RND
 GETX
 GETBYTE
 REG[X]=RAND AND BYTE
 INC CYCLES,36
RETURN
@D
'DRW
 'INC CYCLES,170
 IF F==0 THEN REF=0
 F=1
 IF !BADSP && REF==0 THEN
  BACK
 ELSE
 GETX
 GETY
 GETNIB
 VAR DX=REG[X] AND 63
 VAR DY=REG[Y] AND 31
 REG[&HF]=0
 VAR J,K
 FOR J=0 TO NIB-1
  VAR ROW=MEM[I+J]
  FOR K=0 TO 8-1
   IF ROW AND 1<<7-K THEN
    IF GSPOIT(DX+K,DY+J)==#WHITE THEN
     GPSET DX+K,DY+J,#BLACK
     REG[&HF]=1
    ELSE
     GPSET DX+K,DY+J,#WHITE
    ENDIF
   ENDIF
  NEXT
 NEXT
 F=0
 ENDIF
 
RETURN
@E
'KEY
 GETBYTE
 GETX
 IF BYTE==&H9E THEN
  IF KEYS AND 1<<REG[X] THEN
   SKIP
   INC CYCLES,18
  ELSE
   INC CYCLES,14
  ENDIF
 ELSEIF BYTE==&HA1 THEN
  IF !(KEYS AND 1<<REG[X]) THEN
   SKIP
   INC CYCLES,18
  ELSE
   INC CYCLES,14
  ENDIF
 ELSE
  ERROR "INVALID MODE"
 ENDIF
RETURN
@F
'MEM
 GETX
 GETBYTE
 INC CYCLES,4
 'DT
 IF BYTE==&H07 THEN
  REG[X]=DT
 ELSEIF BYTE==&H0A THEN
  VAR NEW=OLDKEYS AND NOT KEYS
  IF KEYS THEN ST=4
  IF !NEW THEN
   BACK
  ELSE
   FOR II=0 TO 15
    IF NEW AND 1<<II THEN REG[X]=II
   NEXT
  ENDIF
 'DT
 ELSEIF BYTE==&H15 THEN
  DT=REG[X]
 'ST
 ELSEIF BYTE==&H18 THEN
  ST=REG[X]
 'ADDI
 ELSEIF BYTE==&H1E THEN
  I=I+REG[X] AND &HFFFF
 'FONT
 ELSEIF BYTE==&H29 THEN
  I=MEM[REG[X]]
 'BCD
 ELSEIF BYTE==&H33 THEN
  MEM[I]=REG[X] DIV 100
  MEM[I+1]=REG[X] DIV 10 MOD 10
  MEM[I+2]=REG[X] MOD 10
 'SAVE
 ELSEIF BYTE==&H55 THEN
  FOR J=0 TO X
   IF I+J<=&HFFF THEN MEM[I+J]=REG[J]
  NEXT
  IF !BADI THEN I=I+X+1 AND &HFFFF
  INC CYCLES,14+14*(X+1)
 'LOAD
 ELSEIF BYTE==&H65 THEN
  FOR J=0 TO X
   REG[J]=MEM[I+J]
  NEXT
  IF !BADI THEN I=I+X+1 AND &HFFFF
  INC CYCLES,14+14*(X+1)
 ELSE
  ERROR "INVALID MODE"
 ENDIF
RETURN

